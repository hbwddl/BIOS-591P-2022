blockheight=0.5, hspace=500, label.pos="left", block.col="grey",
jitter=0.004, xlab="Time", pch=1)
outbreak
?simulateoutbreak
W <- simulateoutbreak(init.sus=10, inf.rate=0.002, rem.rate=0.001, mut.rate=0.0001,
equi.pop=2000, inoc.size=10, samples.per.time=10,
samp.schedule="calendar", samp.freq=500, mincases=3)
sampledata <- W$sampledata
epidata <- W$epidata
# Calculate distance matrix for observed samples
distmat <- gd(sampledata[,3], W$libr, W$nuc, W$librstrains)
# Now pick colors for sampled isolates
colvec <- rainbow(1200)[1:1000] # Color palette
refnode <- 1 # Compare distance to which isolate?
colv <- NULL # Vector of colors for samples
maxD <- max(distmat[,refnode])
for (i in 1:nrow(sampledata)) {
colv <- c(colv,
colvec[floor((length(colvec)-1)*(distmat[refnode,i])/maxD)+1])
}
plotoutbreak(epidata, sampledata, col=colv, stack=T, arr.len=0.1,
blockheight=0.5, hspace=500, label.pos="left", block.col="grey",
jitter=0.004, xlab="Time", pch=1)
seedy::plotdiversity(epidata,sampledata)
?plotdiversity
plotdiversity(sampledata)
sampledat
sampledata
data(deepseq)
deepseq
?deepseq
?simulatepopulation
seedy::simfixoutbreak()
seedy::simfixoutbreak
?deepseq
D <- plotdiversity(deepseq, sample.times=(1:50)*1000, xlab="Time", ylab="Expected pairwise SNPs")
?diversity.range
supeRinfection::bp_log_likelihood
supeRinfection:::_supeRinfection_seq_log_likelihood
supeRinfection:::supeRinfection_seq_log_likelihood
supeRinfection:::seq_log_likelihood
deepseq
?simulatepopulation
# Generate complete observations at 5 time points
X <- simulatepopulation( m.rate=0.0005, runtime=10000, equi.pop=2000,
sample.times=(1:5)*2000, genomelength=10000,
bottle.times=5000, bottle.size=1, full=TRUE)
X
deepseq
X
plotdiversity(X,sample.times=(1:5)*2000)
X$librstrains
X$libr
plotdiversity(X,sample.times=(1:5)*2000,main="bottle=1")
# Generate complete observations at 5 time points
X <- simulatepopulation( m.rate=0.0005, runtime=10000, equi.pop=2000,
sample.times=(1:5)*2000, genomelength=10000,
bottle.times=5000, bottle.size=5, full=TRUE)
plotdiversity(X,sample.times=(1:5)*2000,main="bottle=5")
# Generate complete observations at 5 time points
X <- simulatepopulation( m.rate=0.0005, runtime=10000, equi.pop=2000,
sample.times=(1:5)*2000, genomelength=10000,
bottle.times=5000, bottle.size=20, full=TRUE)
plotdiversity(X,sample.times=(1:5)*2000,main="bottle=20")
?simulatepopulation
plotdiversity
?invisible
X
seedy:::librtoDNA(X)
?librtoDNA
data(withinhost)
data(withinhost)
library(seedy)
data(withinhost)
withinhost
G <- librtoDNA(sampleID=withinhost$obs.strain, libr=withinhost$libr, nuc=withinhost$nuc,
ref.strain=withinhost$ref.strain, key=withinhost$librstrains, strings=TRUE)
G
length(g)
length(G)
nchar(G[10])
?seedy::plotnetwork
data(outbreak)
K <- networkmat(outbreak$epidata[,1], outbreak$epidata[,4])
plotnetwork(K, labels=outbreak$epidata[,1])
K
K[1,2] <- 0.5
data(outbreak)
K <- networkmat(outbreak$epidata[,1], outbreak$epidata[,4])
plotnetwork(K, labels=outbreak$epidata[,1])
K
K[1,2]
K[1,2] <- 0.5
K
plotnetwork(plotnetwork(K, labels=outbreak$epidata[,1])
)
plotnetwork(K, labels=outbreak$epidata[,1])
K
plotnetwork
seedy::simulatepopulation
?rep
efficacy <- data.frame(group=c(rep(1,11),rep(2,13),rep(3,13)),
score=c(156,119,107,108,100,170,130,154,107,137,107,132,105,144,136,136,132,159,152,117,89,142,151,82,110,117,124,106,113,94,113,121,101,119,77,90,66))
nrow(efficacy)
efficacy
boxplot(score ~ group,data=efficacy)
### To save time we will use the rep() function. This takes a number as its first argument and the number of replicates as its second.
rep(1,10)
group
score
### Save a list of the group data and a list of the score data
group <- c(rep(1,11),rep(2,13),rep(3,13))
score <- c(156,119,107,108,100,170,130,154,107,137,107,132,105,144,136,136,132,159,152,117,89,142,151,82,110,117,124,106,113,94,113,121,101,119,77,90,66)
group
score
## Recall the reference cell coding/dummy variables. R can do this automatically for us by treating group as a "factor"
## This is like the CLASS statement in PROC GLM
## We use the as.factor() function with our group list to make the group into a class, with a reference value
group <- as.factor(c(rep(1,11),rep(2,13),rep(3,13)))
group
efficacy <- data.frame(group,score)
boxplot(score ~ group,data=efficacy)
boxplot(score ~ group,data=efficacy,main="Distribution of score")
anova
lm
?glm
efficacy_anova <- aov(score ~ group,data=efficacy)
efficacy_anova
summary(efficacy_anova)
## To get the R square and Coefficient of Variation
cor(efficacy_anova)
## To get the R square and Coefficient of Variation
efficacy_anova$qr
## To get the R square and Coefficient of Variation
efficacy_anova$effects
lm(score ~ group,data=efficacy)
summary(lm(score ~ group,data=efficacy))
anova(lm(score ~ group,data=efficacy))
efficacy_anova
TukeyHSD(efficacy_anova)
### Perform Bonferroni's adjustment
###### NOT EXPECTED TO KNOW THIS ON THE TESTS
pairwise.t.test(efficacy_anova,p.adjust.method="bonferroni")
### Perform Bonferroni's adjustment
###### NOT EXPECTED TO KNOW THIS ON THE TESTS
pairwise.t.test(score,group,p.adjust.method="bonferroni")
### Perform Bonferroni's adjustment
###### NOT EXPECTED TO KNOW THIS ON THE TESTS
bonferroni <- pairwise.t.test(score,group,p.adjust.method="bonferroni")
bonferroni
summary(bonferroni)
bonferroni
?pairwise.t.test
?p.adjust
### Perform Bonferroni's adjustment
###### NOT EXPECTED TO KNOW THIS ON THE TESTS
## For the Bonferroni correction, you adjust your significance threshold based on the number of tests you are conducting
## Use the p.adjust() function to get an adjusted p-value
## The p.adjust() function takes the initial significance threshold/alpha (typically 0.05), the method ("bonferroni"), and the number of tests
## Let's say we want to conduct three pairwise comparisons after our experiment
p.adjust(0.05,method="bonferroni",3)
## To get the ANOVA table
summary(efficacy_anova)
## We can tell that it's a factor, because when we print it, it tells us the unique levels.
is.factor(group)
boxplot(score ~ group)
lsmeans(efficacy_anova)
### We will need to install the lsmeans package to use the lsmeans() function
install.packages("lsmeans")
library(lsmeans)
library(emmeans)
emmeans::lsmeans(efficacy_anova)
efficacy_anova$
### Perform Tukey's Method for All Pairwise Comparisons
TukeyHSD(efficacy_anova)
efficacy_anova$effects
efficacy_anova$contrasts
efficacy_anova$coefficients
lm(score~group,data=efficacy)
summary(lm(score~group,data=efficacy))
anova(lm(score~group,data=efficacy))
efficacy_anova$fitted.values
efficacy_anova$contrasts
efficacy_anova$effects
efficacy_anova$contrasts$group
efficacy_anova$contrasts
## To get the means of each group
aggregate(score ~ group,data=efficacy,mean)
## To get the means of each group
## We use the aggregate() function. This takes a formula as its first argument, with continuous variable on the left of the ~, then it takes the data= argument
## The last argument in aggregate() is the function that we want to calculate within each group. In this case, we want to calculate the mean
aggregate(score ~ group,data=efficacy,mean)
setwd("~/OneDrive - Emory University/Documents/Work/Bios 591P 2022/R Materials/Homework 8")
# Read in the titanic.csv data
titanic <- read.csv("Titanic Spring 2022.csv")
View(titanic)
# View the data and make sure it read in OK
View(titanic)
# Filling in the blanks in the report:
# Number of passengers who survived
sum(titanic$Survived)
# Percent of passengers who survived
# The percent is just the number of survivors over the total passengers, or the mean of all the 0's (died) and 1's (survived).
mean(titanic$Survived)
# Verify:
sum(titanic$Survived)/nrow(titanic)
## Number of males
# Similar to survival, since 0 = female and 1 = male, we can just sum the 'sex' column
sum(titanic$Sex)
## Percent of males
mean(titanic$Sex)
## Percent of males
mean(titanic$Sex)*100
# Verify:
# The nrow() function gets the number of rows (number of passengers) in the titanic dataset
sum(titanic$Survived)/nrow(titanic)*100
## Count under 15
# We will create a new column in the titanic dataset, and assign it a TRUE/FALSE value if the passenger was under 15
titanic$Child <- titanic$Age < 15
View(titanic)
sum(titanic$Child)
# What happened!
# There are some missing values for age so the sum returns a missing value. We have to set an option to remove missing values
sum(titanic$Child,na.rm=TRUE)
# What happened!
# There are some missing values for age so the sum returns a missing value (NA). We have to set an option (na.rm or 'NA remove') to remove missing values
sum(titanic$Child,na.rm=TRUE)
# What happened!
# There are some missing values for age so the sum returns a missing value (NA). We have to set an option (na.rm or 'NA remove') to remove missing values
sum(titanic$Child,na.rm=TRUE)
# Percent of passengers under 15, make sure you set the na.rm value again
mean(titanic$Child,na.rm=T)
# How to see how many passengers had age available?
# The function is.na() returns TRUE if the value is NA or FALSE if it is not NA (not missing)
sum(is.na(titanic$Age))
# How to see how many passengers had age available?
# The function is.na() returns TRUE if the value is NA or FALSE if it is not NA (not missing)
nrow(titanic) - sum(is.na(titanic$Age))
# Another way to do something--the ! operator inverts TRUE and FALSE. So FALSE becomes TRUE and TRUE becomes FALSE
sum(!is.na(titanic$Age))
## Number of first and second class passengers
# The table() function returns the count of each value in an R list
table(titanic$TicketClass)
# Now we can get the percent for each, by dividing by the total.
# If you divide a list of values in R by one number, it detects that you want to divide each value of the list by the single number
table(titanic$TicketClass)/nrow(titanic)
# Percent of passengers over 15,
1 - mean(titanic$Child,na.rm=T)
?as.factor
titanic$Survived_f <- as.factor(titanic$Survived)
titanic$Child_f <- as.factor(titanic$Child)
titanic$Survived_f <- as.factor(titanic$Survived)
titanic$Sex_f <- as.factor(titanic$Sex)
titanic$Ticket_f <- as.factor(titanic$TicketClass)
titanic$Child_f <- as.factor(titanic$Child)
View(titanic)
# These new factor columns look the same, but if you view each column, you will see they are factors
titanic$Survived_f
titanic$Child_f
?relevel()
relevel(titanic$Child_f,ref=TRUE)
relevel(titanic$Child_f,ref='TRUE')
# We've got a problem here! Observe in the report that X2 = 1 if >= 15, and 0 if < 15
# We've got it reversed--the reference value is FALSE (Age >= 15, according to the way we coded it)
# We want TRUE to be the reference value, so we use the relevel() function to reassign the reference value, using the 'ref=' option
# Put quotes around the value of 'TRUE', since it's been converted to a factor
relevel(titanic$Child_f,ref='TRUE')
titanic$Child_f
# We've got a problem here! Observe in the report that X2 = 1 if >= 15, and 0 if < 15
# We've got it reversed--the reference value is FALSE (Age >= 15, according to the way we coded it)
# We want TRUE to be the reference value, so we use the relevel() function to reassign the reference value, using the 'ref=' option
# Put quotes around the value of 'TRUE', since it's been converted to a factor
# We are going to replace the existing Child_f column. Not necessarily advisable but not the worst thing to do with the relevel() function
titanic$Child_f <- relevel(titanic$Child_f,ref='TRUE')
titanic$Child_f
# Now we move on to fix the reference value for the ticket class
titanic$Ticket_f
# Now we move on to fix the reference value for the ticket class. The reference value should be third class
titanic$Ticket_f
titanic$Ticket_f <- relevel(titanic$Ticket_f,ref='3')
titanic$Ticket_f
titanic$Sex_f
## Conduct chi-square tests for each binary variable associated with survival
chisq.test(titanic$Sex_f)
## Conduct chi-square tests for each binary variable associated with survival
chisq.test(titanic$Sex_f,titanic$Survived_f)
chisq.test(titanic$Child_f,titanic$Survived_f)
chisq.test(titanic$Ticket_f,titanic$Survived_f)
## Fit the logistic regression model
glm(Survived_f ~ Sex_f + Child_f + Ticket_f, data=titanic, family="binomial")
## Fit the logistic regression model
titanic_logistic <- glm(Survived_f ~ Sex_f + Child_f + Ticket_f, data=titanic, family="binomial")
exp(titanic_logistic$coefficients)
summary(titanic_logistic)
# Since these are the log-odds, we have to take the exponent to get the odds ratios
exp(titanic_logistic$coefficients)
# We have to do a little calculation to get the log-odds for 1 vs. 2
# We use the [] brackets to get the 4th and 5th coefficients from the coefficient list
exp(titanic_logistic$coefficients[4] - titanic_logistic$coefficients[5])
# Now to get the 95% ci's of the log odds ratios
confint(titanic_logistic)
# Exponentiate to get the 95% CI of the odds ratios
exp(confint(titanic_logistic))
# We do similar calculations to get the 95% CI for the odds ratio for 1 vs. 2
confint(titanic_logistic)[4,] - confint(titanic_logistic)[5,]
# We do similar calculations to get the 95% CI for the odds ratio for 1 vs. 2
# We use the [] brackets, now to get the fourth and the fifth ROWS of the confidence interval tables (we are getting rows because the comma comes after the 4 and 5)
confint(titanic_logistic)[4,] - confint(titanic_logistic)[5,]
# Exponentiate
exp(confint(titanic_logistic)[4,] - confint(titanic_logistic)[5,])
# We do similar calculations to get the 95% CI for the odds ratio for 1 vs. 2
# We use the [] brackets, now to get the values in the 4th row and 1st column and 5th row and 1st column
confint(titanic_logistic)[4,1] - confint(titanic_logistic)[5,1]
# Same for the second column
confint(titanic_logistic)[4,2] - confint(titanic_logistic)[5,2]
# Exponentiate to get the 95% CI of the odds ratios
exp(confint(titanic_logistic))
confint(titanic_logistic)[4,1]
confint(titanic_logistic)
?confint
confint(titanic_logistic,parm="Ticket_f1")
confint(titanic_logistic)[4,]
confint(titanic_logistic)[4,] - confint(titanic_logistic[5,])
confint(titanic_logistic)[4,] - confint(titanic_logistic)[,5]
confint(titanic_logistic)[4,] - confint(titanic_logistic)[5,]
# Now to get the 95% ci's of the log odds ratios
confint(titanic_logistic)
# Exponentiate to get the 95% CI of the odds ratios
exp(confint(titanic_logistic))
confint(titanic_logistic)[5,1]
# We do similar calculations to get the 95% CI for the odds ratio for 1 vs. 2
# We use the [] brackets, now to get the values in the 4th row and 1st column and 5th row and 1st column
confint(titanic_logistic)[4,1] - confint(titanic_logistic)[5,1]
# We do similar calculations to get the 95% CI for the odds ratio for 1 vs. 2
# We use the [] brackets, now to get the values in the 4th row and 1st column and 5th row and 1st column
exp(confint(titanic_logistic)[4,1] - confint(titanic_logistic)[5,1])
# Exponentiate
exp(confint(titanic_logistic)[4,] - confint(titanic_logistic)[5,])
# To get the C statistic, we use a package: DescTools ('Descriptive tools')
install.packages("DescTools")
library(DescTools)
Cstat(titanic_logistic)
# Exponentiate to get the 95% CI of the odds ratios
exp(confint(titanic_logistic))
exp(4.5)/exp(1.69)
4.5/1.69
exp(4.5-1.69)
log(1.8)
log(4.0)
confint(titanic_logistic)
exp(confint(titanic_logistic))
confint(titanic_logistic$coefficients)
confint(titanic_logistic)
titanic_logistic$contrasts
log(1.7)
log(4.0)
exp(4.5) - exp(1.7)
exp(4.5 - 1.7)
confint(titanic_logistic)
1.5 - .52
exp(0,98)
exp(0/.98)
exp(0.98)
1/2.5
# Exponentiate
exp(confint(titanic_logistic)[4,] - confint(titanic_logistic)[5,])
# Now to get the 95% ci's of the log odds ratios
confint.default(titanic_logistic)
# Exponentiate to get the 95% CI of the odds ratios
exp(confint.default(titanic_logistic))
# We do similar calculations to get the 95% CI for the odds ratio for 1 vs. 2
# We use the [] brackets, now to get the values in the 4th row and 1st column and 5th row and 1st column
confint.default(titanic_logistic)[4,1] - confint.default(titanic_logistic)[5,1]
# Exponentiate
exp(confint.default(titanic_logistic)[4,] - confint.default(titanic_logistic)[5,])
wald.test()
library(aod)
install.packages("aod")
library(aod)
wald.test(b=coef(titanic_logistic),Sigma=vcov(titanic_logistic))
wald.test(b=coef(titanic_logistic),Sigma=vcov(titanic_logistic),Terms=4:5)
OddsRatio(titanic_logistic)
?OddsRatio
# To get the odds ratio of 1 vs 2, we can relevel the ticket class variable and quickly re-do the logistic regression
titanic$Ticket_f2 <- relevel(titanic$Ticket_f,ref="2")
titanic_logistic2 <- glm(Survived_f ~ Sex_f + Child_f + Ticket_f2, data=titanic, family="binomial")
confint(titanic_logistic3)
confint(titanic_logistic2)
exp(confint(titanic_logistic2))
# Another way to get the odds ratio and CI's of 1st class vs 2nd class, and get the 95% CIs, without additional packages, etc, or calculations
# We can relevel the ticket class variable and quickly re-do the logistic regression
titanic$Ticket_f2 <- relevel(titanic$Ticket_f,ref="2")
titanic_logistic2 <- glm(Survived_f ~ Sex_f + Child_f + Ticket_f2, data=titanic, family="binomial")
exp(confint(titanic_logistic2))
exp(coefficients(titanic_logistic2))
# We can do a little calculation to get the log-odds for 1 vs. 2
# We use the [] brackets to get the 4th and 5th coefficients from the coefficient list
exp(coefficients(titanic_logistic)[4] - titanic_logistic$coefficients[5])
# We can do a little calculation to get the log-odds for 1 vs. 2
# We use the [] brackets to get the 4th and 5th coefficients from the coefficient list
exp(coefficients(titanic_logistic)[4] - coefficients(titanic_logistic)[5])
# Since these are the log-odds, we have to take the exponent to get the odds ratios
exp(coefficients(titanic_logistic))
# Desctools also has a nice function for odds ratios
OddsRatio(titanic_logistic)
library(multcomp)
install.packages("multcomp")
setwd("~/OneDrive - Emory University/Documents/Work/Bios 591P 2022/R Materials/Homework 8")
# Read in the titanic.csv data
titanic <- read.csv("Titanic Spring 2022.csv")
# View the data and make sure it read in OK
View(titanic)
########################################
### Filling in the blanks in the report:
########################################
## Number of passengers who survived
# 1 = survived and 0 = didn't survive, so we can just add the data to get the count of who survived
sum(titanic$Survived)
## Percent of passengers who survived
# The percent is just the number of survivors over the total passengers, or the mean of all the 0's (died) and 1's (survived), multiplied by 100 to convert it to percent.
mean(titanic$Survived)*100
# Verify:
# The nrow() function gets the number of rows (number of passengers) in the titanic dataset
sum(titanic$Survived)/nrow(titanic)*100
## Number of males
# Similar to survival, since 0 = female and 1 = male, we can just sum the 'sex' column
sum(titanic$Sex)
## Percent of males
mean(titanic$Sex)*100
## Count under 15
# We will create a new column in the titanic dataset, and assign it a TRUE/FALSE value if the passenger was under 15
titanic$Child <- titanic$Age < 15
View(titanic)
# We add TRUE and FALSE values as if they are 1 for true and 0 for false
sum(titanic$Child)
# What happened!?
# There are some missing values for age so the sum returns a missing value (NA). We have to set an option (na.rm or 'NA remove') to remove missing values
sum(titanic$Child,na.rm=TRUE)
# Percent of passengers under 15, make sure you set the na.rm value again
mean(titanic$Child,na.rm=T)
# Percent of passengers over 15,
1 - mean(titanic$Child,na.rm=T)
# How to see how many passengers had age available?
# The function is.na() returns TRUE if the value is NA or FALSE if it is not NA (not missing)
nrow(titanic) - sum(is.na(titanic$Age)) # Total passengers minus number with missing age
# Another way to do this--the ! operator, placed in front of a TRUE/FALSE statement, inverts TRUE and FALSE. So FALSE becomes TRUE and TRUE becomes FALSE
sum(!is.na(titanic$Age))
## Number of first and second class passengers
# The table() function returns a list which contains the count of each value in an R list
table(titanic$TicketClass)
## Percent of first and second class passengers
# Now we can get the percent for each, by dividing by the total.
# If you divide a list of values in R by a single number, it detects that you want to divide each value of the list by the single number
table(titanic$TicketClass)/nrow(titanic)
###################################
## Code dummy variables/factors
###################################
# Recall that R can handle dummy variables itself, if you put the data into a 'factor'
# We convert a list into a factor with the as.factor() function
# Let's add each variable as a factor in a new column in the titanic dataset
# You can name the new columns whatever you want, I just added the _f at the end of the name
titanic$Survived_f <- as.factor(titanic$Survived)
titanic$Sex_f <- as.factor(titanic$Sex)
titanic$Ticket_f <- as.factor(titanic$TicketClass)
titanic$Child_f <- as.factor(titanic$Child)
View(titanic)
# These new factor columns look the same, but if you view each column, you will see they are factors
titanic$Survived_f
# You can tell it is a factor by the "Levels:" list at the bottom when you print it out.
# The first value listed after "Levels:" is the reference value. So this is saying that for the 'Survived_f' variable, the reference value is 0. R assigns reference alphabetically by default.
titanic$Child_f
# We've got a problem here! Observe in the report that X2 = 1 if >= 15, and 0 if < 15
# We've got it reversed--the reference value is FALSE (Age >= 15, according to the way we coded it)
# We want TRUE to be the reference value, so we use the relevel() function to reassign the reference value, using the 'ref=' option
# Put quotes around the value of 'TRUE', since it's been converted to a factor
# We are going to replace the existing Child_f column. Not necessarily advisable but not the worst thing to do with the relevel() function
titanic$Child_f <- relevel(titanic$Child_f,ref='TRUE')
titanic$Child_f
# It's fixed!
titanic$Sex_f
# The reference looks okay for Sex
# Now we move on to fix the reference value for the ticket class. The reference value should be third class
titanic$Ticket_f
titanic$Ticket_f <- relevel(titanic$Ticket_f,ref='3')
titanic$Ticket_f # Looks better
## Conduct chi-square tests for each binary variable associated with survival
chisq.test(titanic$Sex_f,titanic$Survived_f)
chisq.test(titanic$Child_f,titanic$Survived_f)
chisq.test(titanic$Ticket_f,titanic$Survived_f)
######################################
## Fitting the logistic regression model
######################################
# We use the glm() function (generalized linear model)
# This function takes in the regression formula and data as before, but now we specify family="binomial" in order to tell glm() to fit a logistic regression model
titanic_logistic <- glm(Survived_f ~ Sex_f + Child_f + Ticket_f, data=titanic, family="binomial")
summary(titanic_logistic)
library(multcomp)
titanic_class_test <- glht(titanic_logistic,mcp(Ticket_f="Tukey"))
titanic_class_test
exp(coefficients(titanic_class_test))
# Invert odds ratio
1/exp(coefficients(titanic_class_test))
exp(confint(titanic_class_test))
exp(confint.default(titanic_class_test))
# Invert 95% CIs
1/exp(confint.default(titanic_class_test))
# Another way to get the odds ratio and CI's of 1st class vs 2nd class, and get the 95% CIs, without additional packages, etc, or calculations
# Just relevel the ticket class variable and quickly re-do the logistic regression
titanic$Ticket_f2 <- relevel(titanic$Ticket_f,ref="2")
titanic_logistic2 <- glm(Survived_f ~ Sex_f + Child_f + Ticket_f2, data=titanic, family="binomial")
exp(coefficients(titanic_logistic2))
exp(confint(titanic_logistic2))
